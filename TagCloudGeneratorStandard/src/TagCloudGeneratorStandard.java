import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

/**
 * Takes a .txt file and a number from the user and outputs a .html page with a
 * tag cloud consist of the top required number of words with the most counts
 * and alphabetically sorted words.
 *
 * @author Christian Alexander and Lang Xu
 *
 */

public final class TagCloudGeneratorStandard {

    /**
     * Global Final Variables: Maximum font size.
     */
    private static final int FONT_MAX = 48;

    /**
     * Global Final Variables: Minimum font size.
     */
    private static final int FONT_MIN = 11;

    /**
     * Global Variables: Maximum Count.
     */
    private static int max = 0;

    /**
     * Global Variables: Minimum Count.
     */
    private static int min;

    /**
     * Nested class for string comparator.
     */
    private static class StringLT
            implements Comparator<Map.Entry<String, Integer>> {
        @Override
        public int compare(Map.Entry<String, Integer> o1,
                Map.Entry<String, Integer> o2) {
            return o1.getKey().toLowerCase()
                    .compareTo(o2.getKey().toLowerCase());
        }
    }

    /**
     * Nested class for integer comparator.
     */
    private static class CountLT
            implements Comparator<Map.Entry<String, Integer>> {
        @Override
        public int compare(Map.Entry<String, Integer> o1,
                Map.Entry<String, Integer> o2) {
            return o2.getValue().compareTo(o1.getValue());
        }
    }

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private TagCloudGeneratorStandard() {
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Words counted in (name of input file) </title>
     * </head> <body>
     * <h2>Words counted in (name of input file)</h2>
     * <table>
     *
     * @param fileName
     *            name of the file input by the user
     * @param required
     *            number of words requested by the user
     * @param out
     *            the output stream
     * @updates out.content
     * @requires fileName != null and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(String fileName, int required,
            PrintWriter out) {
        assert fileName != null : "Violation of: channel is not null";
        assert out != null : "Violation of: out is not null";

        out.println("<html>");
        out.println("<head>");
        out.println("<title>Top " + required + " words in " + fileName
                + "</title>");
        out.println(
                "<link href=\"http://web.cse.ohio-state.edu/software/2231/web-"
                        + "sw2/assignments/projects/tag-cloud-generator/data/tagcloud"
                        + ".css\" rel=\"stylesheet\" type=\"text/css\">");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>Top " + required + " words in " + fileName + "</h2>");
        out.println("<hr>");
        out.println("<div class=\"cdiv\">");
        out.println("<p class=\"cbox\">");

    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </table>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    private static void outputFooter(PrintWriter out) {
        assert out != null : "Violation of: out is not null";

        out.println("</p>");
        out.println("</div>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    private static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        int index = position;
        String answer = "";

        if (!separators.contains(text.charAt(index))) {
            while (index < text.length()
                    && !separators.contains(text.charAt(index))) {
                index++;
            }
        } else {
            while (index < text.length()
                    && separators.contains(text.charAt(index))) {
                index++;
            }
        }

        answer = text.substring(position, index);
        return answer;
    }

    /**
     * Fills the separator set with the characters necessary to separate the
     * words from the separators.
     *
     * @param sepSet
     *            the @code set) that contains all the separator characters
     * @requires sepSet != null
     * @ensures sepSet = #sepSet * sepChars
     */
    public static void fillSep(Set<Character> sepSet) {
        assert sepSet != null : "Violation of : sepSet is not null";

        String sepChars = " \t\n\r,-.!?[]';:/()";

        for (int i = 0; i < sepChars.length(); i++) {
            sepSet.add(sepChars.charAt(i));
        }

    }

    /**
     * Finds all of the words in the user given file and stores them in a map,
     * with keys as the words and values as the amount of times they appear in
     * the document.
     *
     * @param words
     *            the (@code Map) that stores the words and the amount of times
     *            they appear in pairs
     * @param inputFile
     *            the input stream given by user
     * @requires words != null and inputFile is open
     * @ensures words = #words * [the "words" found in inputFile, amount of
     *          appearances in inputFile]
     */
    private static void wordFinder(Map<String, Integer> words,
            BufferedReader inputFile) {
        assert words != null : "Violation of : words is not null";
        assert inputFile != null;

        Set<Character> separators = new HashSet<Character>();
        fillSep(separators);

        try {
            String currentLine = inputFile.readLine();
            while (currentLine != null) {
                int index = 0;
                while (index < currentLine.length()) {
                    String foundWord = nextWordOrSeparator(currentLine, index,
                            separators);
                    String temp = foundWord.toLowerCase();
                    if (!separators.contains(temp.charAt(0))) {
                        if (!words.keySet().contains(temp)) {
                            words.put(temp, 1);
                        } else {
                            int count = words.put(temp, 1);
                            count++;
                            count = words.put(temp, count);
                        }
                    }
                    index = index + foundWord.length();
                }
                currentLine = inputFile.readLine();
            }
        } catch (IOException e) {
            System.err.println("ERROR: error reading lines from the file.");
        }

    }

    /**
     * sort the {@code required} number of words with the most count
     * lexicographically using a list, return the sorted list.
     *
     * @param raw
     *            a raw map with pairs consist of words and their counts
     * @param required
     *            number of words requested by the user
     * @requires words != null and words.size() >= {@code required}
     * @updates {@code max},{@code min}
     * @clears {@code raw}
     * @return {@code string}, sorting machine with top {@code required} number
     *         of words
     */
    private static List<Map.Entry<String, Integer>> sortMap(
            Map<String, Integer> raw, int required) {
        assert raw != null;

        Comparator<Map.Entry<String, Integer>> countSort = new CountLT();
        Comparator<Map.Entry<String, Integer>> stringSort = new StringLT();
        List<Map.Entry<String, Integer>> count = new ArrayList<Map.Entry<String, Integer>>();
        List<Map.Entry<String, Integer>> string = new ArrayList<Map.Entry<String, Integer>>();

        for (Map.Entry<String, Integer> pair : raw.entrySet()) {
            count.add(pair);
        }

        Collections.sort(count, countSort);
        int i = 0;
        while (i < required) {
            Map.Entry<String, Integer> countSorted = count.remove(0);
            if (i == 0) {
                max = countSorted.getValue();
            }
            if (i == required - 1) {
                min = countSorted.getValue();
            }
            string.add(countSorted);
            i++;
        }
        Collections.sort(string, stringSort);

        return string;
    }

    /**
     * Calculate font size according to {@code max},{@code min},
     * {@code FONT_MAX}, {@code FONT_MIN}.
     *
     * @param currentCount
     *            count of a specific word
     * @return the calculated font size
     * @ensures font =((FONT_MAX - FONT_MIN) * (currentCount - min)) / (max -
     *          min) + FONT_MIN;
     */
    public static int fontGenerator(int currentCount) {
        int font;

        if (max == min) {
            font = FONT_MAX;
        } else {
            font = ((FONT_MAX - FONT_MIN) * (currentCount - min)) / (max - min)
                    + FONT_MIN;
        }

        return font;
    }

    /**
     * Outputs the "table" components necessary to fill the tag cloud space in
     * the generated HTML file. These are the expected elements generated by
     * this method:
     *
     * <span style="cursor:default" class="f" + fontSize + " title="count: " +
     * thisPair.value() + "\">" + thisPair.key()</span>
     *
     * @param fileOut
     *            .html file name for output stream
     * @param string
     *            sorting machine to sort strings alphabetically
     * @updates out.content
     * @clears string
     * @requires string != null and fileOut.is_open
     * @ensures out.content = #out.content * [the "table" content]
     */
    public static void tableFill(PrintWriter fileOut,
            List<java.util.Map.Entry<String, Integer>> string) {
        assert fileOut != null;
        assert string != null;

        int size = string.size();
        int i = 0;

        while (i < size) {
            Map.Entry<String, Integer> thisPair = string.remove(0);
            int fontSize = fontGenerator(thisPair.getValue());
            fileOut.println("<span style=\"cursor:default\" class=\"f"
                    + fontSize + "\" title=\"count: " + thisPair.getValue()
                    + "\">" + thisPair.getKey() + "</span>");
            i++;
        }

    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        Map<String, Integer> words = new HashMap<String, Integer>();

        /* fetch required number of words */
        System.out.print("How many words would you like to include? ");
        int required = Integer.parseInt(in.nextLine());

        /* fetch input file name */
        System.out.print("What is the name of your input file? (.txt): ");
        BufferedReader input;
        String fileName = in.nextLine();
        try {
            input = new BufferedReader(new FileReader(fileName));
        } catch (IOException e) {
            System.err.println("ERROR: Input file not valid");
            in.close();
            return;
        }

        /* fetch output file name */
        System.out.print(
                "What would you like the output file to be named? (.html): ");
        PrintWriter fileOut;
        try {

            fileOut = new PrintWriter(
                    new BufferedWriter(new FileWriter(in.nextLine())));
        } catch (IOException e) {
            System.err.println("ERROR: invalid output name");
            try {
                input.close();
                in.close();
            } catch (IOException f) {
                System.err.println("ERROR: error closing input reader.");
            }
            return;
        }

        outputHeader(fileName, required, fileOut); // output header

        wordFinder(words, input); // find all the words

        if (!(words.size() < required)) { // if the required number of words is smaller than total number

            List<Map.Entry<String, Integer>> stringSort = sortMap(words,
                    required); // sort the map

            tableFill(fileOut, stringSort); // fill the table

            outputFooter(fileOut); // output the footer
        } else {
            System.err
                    .println("ERROR: Number of words bigger than input given"); // error message
        }

        in.close();
        fileOut.close();

        try {
            input.close();
        } catch (IOException e) {
            System.err.println("ERROR:error closing input reader");
        }
    }

}
